import { state } from "./state";
import { actions } from "./actions";
import { storeGen } from ".";
export declare type State = typeof state;
export declare type Actions = typeof actions;
export declare type Store = ReturnType<typeof storeGen>;
export declare interface Context {
    state: State;
    actions: Actions;
    getters: any;
}
declare type Func = (context: Context, ...args: any) => any;
export declare type ActionsModuleMapper<AM extends {
    [s: string]: {
        [y: string]: Func;
    };
}> = {
    [Module in keyof AM]: ActionsMapper<AM[Module]>;
};
declare type ActionsMapper<Module extends {
    [s: string]: Func;
}> = {
    [A in keyof Module]: ChangedFunction<Module[A]>;
};
declare class Wrapper<T extends Func, C extends Context = Context> {
    wrapped(e: T, context: C): (...args: RemoveFirstFromTuple<Parameters<T>>) => ReturnType<T>;
}
declare type FunctionChanger<T extends Func> = ReturnType<Wrapper<T>['wrapped']>;
declare type ChangedFunction<F extends Func> = FunctionChanger<F>;
export declare type ExcludeFromTuple<T extends readonly any[], E> = T extends [infer F, ...infer R] ? [F] extends [E] ? ExcludeFromTuple<R, E> : [
    F,
    ...ExcludeFromTuple<R, E>
] : [];
export declare type RemoveFirstFromTuple<T extends any[]> = T['length'] extends 0 ? [] : (((...b: T) => void) extends (a: any, ...b: infer I) => void ? I : []);
export {};
